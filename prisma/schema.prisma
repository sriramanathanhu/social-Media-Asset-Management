// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int      @id @default(autoincrement())
  email       String   @unique
  name        String
  ecitizen_id String?
  role        String   @default("read") // read, write, manager, admin
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  // Relations
  userEcosystems        UserEcosystem[]
  credentialHistory     CredentialHistory[] @relation("ChangedBy")
  assignedBy            UserEcosystem[]     @relation("AssignedBy")
  platformAuditLogs     PlatformAuditLog[]
  platformAccess        PlatformAccess[]    @relation("PlatformAccessUser")
  grantedPlatformAccess PlatformAccess[]    @relation("PlatformAccessGrantedBy")
  resources             Resource[]          @relation("ResourceAuthor")

  // Secure Logins relations
  secureLogins                  SecureLogin[]             @relation("SecureLoginOwner")
  secureLoginFolders            SecureLoginFolder[]       @relation("SecureLoginFolderOwner")
  secureLoginGroups             SecureLoginGroup[]        @relation("SecureLoginGroupOwner")
  secureLoginGroupMemberships   SecureLoginGroupMember[]  @relation("SecureLoginGroupMember")
  addedSecureLoginGroupMembers  SecureLoginGroupMember[]  @relation("SecureLoginGroupMemberAddedBy")
  secureLoginUserAccess         SecureLoginUserAccess[]   @relation("SecureLoginUserAccess")
  grantedSecureLoginUserAccess  SecureLoginUserAccess[]   @relation("SecureLoginUserAccessGrantedBy")
  grantedSecureLoginGroupAccess SecureLoginGroupAccess[]  @relation("SecureLoginGroupAccessGrantedBy")
  secureLoginHistory            SecureLoginHistory[]      @relation("SecureLoginHistoryChangedBy")
}

model Ecosystem {
  id            Int      @id @default(autoincrement())
  name          String   @unique
  theme         String
  description   String?
  active_status Boolean  @default(true)
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  // Relations
  platforms      SocialMediaPlatform[]
  userEcosystems UserEcosystem[]
}

model UserEcosystem {
  id           Int      @id @default(autoincrement())
  user_id      Int
  ecosystem_id Int
  assigned_by  Int?
  assigned_at  DateTime @default(now())
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  // Relations
  user       User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  ecosystem  Ecosystem @relation(fields: [ecosystem_id], references: [id], onDelete: Cascade)
  assignedBy User?     @relation("AssignedBy", fields: [assigned_by], references: [id])

  @@unique([user_id, ecosystem_id]) // Prevent duplicate assignments
}

model SocialMediaPlatform {
  id                  Int       @id @default(autoincrement())
  ecosystem_id        Int
  platform_name       String
  platform_type       String
  account_status      String    @default("active")
  login_method        String    @default("email_password") // email_password, google_oauth, facebook_oauth, apple_id
  profile_url         String?
  profile_id          String?
  username            String? // Encrypted - for display/internal use, NOT for generating profile URL
  password            String? // Encrypted
  email               String?
  phone               String?
  recovery_email      String?
  recovery_phone      String?
  two_fa_enabled      Boolean   @default(false)
  totp_enabled        Boolean   @default(false)
  totp_secret         String? // Encrypted
  bio                 String?
  profile_image_url   String?
  cover_image_url     String?
  verification_status String    @default("unverified")
  notes               String?
  created_at          DateTime  @default(now())
  updated_at          DateTime  @updatedAt
  last_checked        DateTime?
  last_posted         DateTime?
  followers_count     Int?
  following_count     Int?
  posts_count         Int?

  // New fields
  live_stream           String? // Enabled, Not Enabled, Not Applicable
  language              String?
  status                String? // Active, Suspended, Terminated, Able to access, Incorrect Password, Missing Password, Requires Phone no
  recovery_phone_number String?
  recovery_email_id     String?
  added_phone_number    String?
  phone_number_owner    String?
  branding              String? // Completed, Partial, Nothing
  connection_tool       String? // Sprinklr, Getlate, None

  // Relations
  ecosystem         Ecosystem           @relation(fields: [ecosystem_id], references: [id], onDelete: Cascade)
  credentialHistory CredentialHistory[]
  auditLogs         PlatformAuditLog[]
  platformAccess    PlatformAccess[]

  @@unique([ecosystem_id, platform_name])
}

model CredentialHistory {
  id          Int      @id @default(autoincrement())
  platform_id Int
  field_name  String
  old_value   String? // Encrypted
  new_value   String? // Encrypted
  changed_by  Int
  changed_at  DateTime @default(now())
  created_at  DateTime @default(now())

  // Relations
  platform  SocialMediaPlatform @relation(fields: [platform_id], references: [id], onDelete: Cascade)
  changedBy User                @relation("ChangedBy", fields: [changed_by], references: [id])
}

model EmailId {
  id             Int      @id @default(autoincrement())
  email_address  String   @unique
  ecosystem_name String?
  primary_use    String?
  status         String   @default("active")
  created_by     String?
  notes          String?
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  // Secure Logins relation (for Google OAuth accounts)
  secureLogins SecureLogin[]
}

model PlatformTemplate {
  id                Int      @id @default(autoincrement())
  platform_name     String   @unique
  platform_category String
  base_url          String?
  name_format       String?
  bio_format        String?
  url_format        String?
  notes             String?
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt
}

model PlatformAuditLog {
  id          Int      @id @default(autoincrement())
  platform_id Int
  action      String // create, update, delete
  field_name  String? // for updates, which field changed
  old_value   String? // previous value (for non-sensitive fields)
  new_value   String? // new value (for non-sensitive fields)
  user_id     Int
  user_role   String // role at time of action
  ip_address  String?
  user_agent  String?
  created_at  DateTime @default(now())

  // Relations
  platform SocialMediaPlatform @relation(fields: [platform_id], references: [id], onDelete: Cascade)
  user     User                @relation(fields: [user_id], references: [id])
}

model PlatformAccess {
  id           Int      @id @default(autoincrement())
  platform_id  Int
  user_id      Int
  access_level String // Platform-specific role: admin, editor, moderator, analyst, etc.
  granted_by   Int? // User who granted this access
  granted_at   DateTime @default(now())
  notes        String? // Additional notes about this access
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  // Relations
  platform      SocialMediaPlatform @relation(fields: [platform_id], references: [id], onDelete: Cascade)
  user          User                @relation("PlatformAccessUser", fields: [user_id], references: [id], onDelete: Cascade)
  grantedByUser User?               @relation("PlatformAccessGrantedBy", fields: [granted_by], references: [id])

  @@unique([platform_id, user_id, access_level]) // Prevent duplicate access assignments
}

model Resource {
  id         Int      @id @default(autoincrement())
  title      String
  content    String // Blog post content / SOP content
  category   String   @default("sop") // sop, guide, documentation, etc.
  author_id  Int
  published  Boolean  @default(false)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Relations
  author User @relation("ResourceAuthor", fields: [author_id], references: [id])
}

model EmailSettings {
  id           Int      @id @default(autoincrement())
  sendgrid_api_key String?
  from_email   String?
  from_name    String?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt
}

// ==========================================
// SECURE LOGINS (PASSWORD VAULT) MODELS
// ==========================================

model SecureLoginFolder {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  color       String?  @default("#6366f1") // Folder color for UI
  icon        String?  @default("folder") // Icon name for UI
  parent_id   Int?     // For nested folders
  owner_id    Int
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  // Relations
  owner    User                 @relation("SecureLoginFolderOwner", fields: [owner_id], references: [id], onDelete: Cascade)
  parent   SecureLoginFolder?   @relation("FolderHierarchy", fields: [parent_id], references: [id], onDelete: SetNull)
  children SecureLoginFolder[]  @relation("FolderHierarchy")
  logins   SecureLogin[]

  @@unique([name, owner_id, parent_id]) // Unique folder name per owner at same level
}

model SecureLogin {
  id                Int       @id @default(autoincrement())
  item_name         String
  username          String?   // Encrypted
  password          String?   // Encrypted
  totp_secret       String?   // Encrypted - TOTP Authenticator Key
  website_url       String?
  notes             String?
  login_type        String    @default("email_password") // email_password, google_oauth
  google_account_id Int?      // Reference to EmailId for Google OAuth
  folder_id         Int?      // Folder organization
  owner_id          Int
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt

  // Relations
  owner         User                    @relation("SecureLoginOwner", fields: [owner_id], references: [id], onDelete: Cascade)
  googleAccount EmailId?                @relation(fields: [google_account_id], references: [id])
  folder        SecureLoginFolder?      @relation(fields: [folder_id], references: [id], onDelete: SetNull)
  userAccess    SecureLoginUserAccess[]
  groupAccess   SecureLoginGroupAccess[]
  history       SecureLoginHistory[]
}

model SecureLoginGroup {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  owner_id    Int
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  // Relations
  owner       User                      @relation("SecureLoginGroupOwner", fields: [owner_id], references: [id], onDelete: Cascade)
  members     SecureLoginGroupMember[]
  loginAccess SecureLoginGroupAccess[]

  @@unique([name, owner_id]) // Unique group name per owner
}

model SecureLoginGroupMember {
  id       Int      @id @default(autoincrement())
  group_id Int
  user_id  Int
  role     String   @default("member") // member, admin (group admin)
  added_by Int?
  added_at DateTime @default(now())

  // Relations
  group       SecureLoginGroup @relation(fields: [group_id], references: [id], onDelete: Cascade)
  user        User             @relation("SecureLoginGroupMember", fields: [user_id], references: [id], onDelete: Cascade)
  addedByUser User?            @relation("SecureLoginGroupMemberAddedBy", fields: [added_by], references: [id])

  @@unique([group_id, user_id])
}

model SecureLoginUserAccess {
  id              Int      @id @default(autoincrement())
  secure_login_id Int
  user_id         Int
  access_level    String   // read, edit
  granted_by      Int?
  granted_at      DateTime @default(now())

  // Relations
  secureLogin   SecureLogin @relation(fields: [secure_login_id], references: [id], onDelete: Cascade)
  user          User        @relation("SecureLoginUserAccess", fields: [user_id], references: [id], onDelete: Cascade)
  grantedByUser User?       @relation("SecureLoginUserAccessGrantedBy", fields: [granted_by], references: [id])

  @@unique([secure_login_id, user_id])
}

model SecureLoginGroupAccess {
  id              Int      @id @default(autoincrement())
  secure_login_id Int
  group_id        Int
  access_level    String   // read, edit
  granted_by      Int?
  granted_at      DateTime @default(now())

  // Relations
  secureLogin   SecureLogin      @relation(fields: [secure_login_id], references: [id], onDelete: Cascade)
  group         SecureLoginGroup @relation(fields: [group_id], references: [id], onDelete: Cascade)
  grantedByUser User?            @relation("SecureLoginGroupAccessGrantedBy", fields: [granted_by], references: [id])

  @@unique([secure_login_id, group_id])
}

model SecureLoginHistory {
  id              Int      @id @default(autoincrement())
  secure_login_id Int
  action          String   // create, update, delete, access_granted, access_revoked
  field_name      String?
  old_value       String?  // Encrypted for sensitive fields
  new_value       String?  // Encrypted for sensitive fields
  changed_by      Int
  ip_address      String?
  user_agent      String?
  created_at      DateTime @default(now())

  // Relations
  secureLogin   SecureLogin @relation(fields: [secure_login_id], references: [id], onDelete: Cascade)
  changedByUser User        @relation("SecureLoginHistoryChangedBy", fields: [changed_by], references: [id])
}
